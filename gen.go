// Copyright 2015 Mikio Hara. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

//go:generate go run gen.go

// This program generates STUN parameters by reading IANA protocol
// registries.
package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)

var registries = []struct {
	url   string
	parse func(io.Writer, io.Reader) error
}{
	{
		"http://www.iana.org/assignments/stun-parameters/stun-parameters.xml",
		parseSTUNParameters,
	},
}

func main() {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "// go generate gen.go\n")
	fmt.Fprintf(&bb, "// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT\n\n")
	fmt.Fprintf(&bb, "package stun\n\n")
	for _, r := range registries {
		resp, err := http.Get(r.url)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		defer resp.Body.Close()
		if resp.StatusCode != http.StatusOK {
			fmt.Fprintf(os.Stderr, "got HTTP status code %v for %v\n", resp.StatusCode, r.url)
			os.Exit(1)
		}
		if err := r.parse(&bb, resp.Body); err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		fmt.Fprintf(&bb, "\n")
	}
	b, err := format.Source(bb.Bytes())
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if err := ioutil.WriteFile("const.go", b, 0644); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func parseSTUNParameters(w io.Writer, r io.Reader) error {
	dec := xml.NewDecoder(r)
	var sps stunParameters
	if err := dec.Decode(&sps); err != nil {
		return err
	}
	csps := sps.escape()
	for _, csp := range csps {
		switch csp.Title {
		case "STUN Methods", "STUN Attributes", "STUN Error Codes":
		default:
			continue
		}
		fmt.Fprintf(w, "// %s, %s, Updated: %s\n", sps.Title, csp.Title, sps.Updated)
		fmt.Fprintf(w, "const (\n")
		for _, r := range csp.Records {
			switch csp.Title {
			case "STUN Methods":
				fmt.Fprintf(w, "Method%s Method = %s", r.Descr, r.Value)
				fmt.Fprintf(w, "// %s\n", r.OrigDescr)
			case "STUN Attributes":
				fmt.Fprintf(w, "attr%s = %s", r.Descr, r.Value)
				fmt.Fprintf(w, "// %s\n", r.OrigDescr)
			case "STUN Error Codes":
				fmt.Fprintf(w, "Status%s = %s", r.Descr, r.Value)
				fmt.Fprintf(w, "// %s\n", r.OrigDescr)
			}
		}
		fmt.Fprintf(w, ")\n\n")
		switch csp.Title {
		case "STUN Methods":
		default:
			continue
		}
		sr := strings.NewReplacer(
			"Create", "Create ",
			"Channel", "Channel ",
			"Connection", "Connection ",
		)
		fmt.Fprintf(w, "var methods = map[Method]string{\n")
		for _, r := range csp.Records {
			r.OrigDescr = sr.Replace(r.OrigDescr)
			fmt.Fprintf(w, "%s: %q,\n", r.Value, strings.ToLower(r.OrigDescr))
		}
		fmt.Fprintf(w, "}\n")
	}
	return nil
}

type stunParameters struct {
	XMLName    xml.Name `xml:"registry"`
	Title      string   `xml:"title"`
	Created    string   `xml:"created"`
	Updated    string   `xml:"updated"`
	Registries []struct {
		Title   string `xml:"title"`
		Records []struct {
			Value string `xml:"value"`
			Descr string `xml:"description"`
		} `xml:"record"`
	} `xml:"registry"`
}

type canonSTUNParameter struct {
	Title   string
	Records []canonSTUNParamRecord
}

type canonSTUNParamRecord struct {
	Value     string
	Descr     string
	OrigDescr string
}

func (sp *stunParameters) escape() []canonSTUNParameter {
	attrsr := strings.NewReplacer("-", "_", " ", "_")
	errsr := strings.NewReplacer(" ", "")
	var ps []canonSTUNParameter
	for _, reg := range sp.Registries {
		p := canonSTUNParameter{Title: reg.Title}
		for _, r := range reg.Records {
			if strings.Contains(r.Descr, "Reserved") || strings.Contains(r.Descr, "Unassigned") || strings.Contains(r.Value, "-") {
				continue
			}
			pr := canonSTUNParamRecord{Value: r.Value, OrigDescr: r.Descr}
			switch reg.Title {
			case "STUN Attributes":
				pr.Descr = attrsr.Replace(r.Descr)
			case "STUN Error Codes":
				pr.Descr = errsr.Replace(r.Descr)
			default:
				pr.Descr = r.Descr
			}
			p.Records = append(p.Records, pr)
		}
		ps = append(ps, p)
	}
	return ps
}
